---
import '../assets/item.css'
import dayjs from '../lib/dayjs'
import { getEnv } from '../lib/env'

const locale = getEnv(import.meta.env, Astro, 'LOCALE')
const timezone = getEnv(import.meta.env, Astro, 'TIMEZONE')

locale && dayjs.locale(locale)

const { SITE_URL } = Astro.locals
const { post, isItem } = Astro.props

const channel = getEnv(import.meta.env, Astro, 'CHANNEL')
const COMMENTS = getEnv(import.meta.env, Astro, 'COMMENTS')

const datetime = dayjs(post.datetime).tz(timezone)
const timeago = datetime.isBefore(dayjs().subtract(1, 'w')) ? datetime.format('HH:mm · ll · ddd') : datetime.fromNow()
---

<div class="item" style={{ 'view-transition-name': `post-${post.id}` }}>
  <div class="time-box">
    <div class="dot"></div>
    <div class="time">
      <a href={`${SITE_URL}posts/${post.id}`} title={post.datetime} class="item-link">
        <time datetime={post.datetime} title={timeago}>{timeago}</time>
      </a>
    </div>
  </div>
  {post.content.length > 0 && <div class={`text-box content`} set:html={post.content} />}
  {
    post.tags.length > 0 && (
      <div class="tag-box" style={post.content.length === 0 ? 'padding-top: 30px;' : ''}>
        <div class="tag-icon" />
        {post.tags.map((tag) => (
          <a href={`/search/%23${tag}`} title={tag} class="tag">
            {tag}
          </a>
        ))}
      </div>
    )
  }

  {
    COMMENTS && isItem && (
      <div class="comments">
        <script
          is:inline
          async
          src="https://telegram.org/js/telegram-widget.js"
          data-telegram-discussion={`${channel}/${post.id}`}
          data-comments-limit="50"
          data-colorful="1"
          data-color="454545"
        />
      </div>
    )
  }

  <script is:inline>
    (() => {
      const script = document.currentScript;
      const root = script?.closest('.item');
      if (!root) return;
      const content = root.querySelector('.content');
      if (!content) return;
      const imgs = Array.from(content.querySelectorAll('img'));
      if (imgs.length === 0) return;

      // 绑定点击打开预览
      imgs.forEach((img, idx) => {
        if (img.dataset.previewBound === '1') return;
        img.dataset.previewBound = '1';
        img.style.cursor = 'zoom-in';
        img.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openModal(idx);
        }, { passive: false });
      });

      let currentIndex = 0;
      let overlay = null;
      let modalImg = null;
      let scale = 1;
      let translateX = 0, translateY = 0;
      let isDragging = false, dragStartX = 0, dragStartY = 0, originX = 0, originY = 0;
      let touchStartX = 0, touchStartY = 0, touchMoved = false;
      let lastDbl = 0;
      let lastTap = 0, lastTapX = 0, lastTapY = 0;
      let bodyOverflowPrev = '';
      let pinchLastDist = 0;

      function buildOverlay() {
        overlay = document.createElement('div');
        overlay.className = 'modal';
        overlay.style.display = 'none';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.tabIndex = -1;
        // 添加图片与关闭按钮，挂载到 body 确保绝对置顶
        overlay.innerHTML = `<img class="modal-img" alt="" /><button class="modal-close" aria-label="关闭预览">×</button>`;
        document.body.appendChild(overlay);
        modalImg = overlay.querySelector('.modal-img');
        const closeBtn = overlay.querySelector('.modal-close');
        if (closeBtn) {
          closeBtn.addEventListener('click', (e) => { e.stopPropagation(); close(); });
        }

        // 点击遮罩关闭预览
        overlay.addEventListener('click', (ev) => {
          if (ev.target !== overlay) return; // 只在点击遮罩时
          close();
        });
        // 触摸点击遮罩关闭
        overlay.addEventListener('touchend', (ev) => {
          if (ev.target === overlay) close();
        });

        // 右键关闭
        overlay.addEventListener('contextmenu', (e) => { e.preventDefault(); close(); });

        // 键盘
        document.addEventListener('keydown', onKey);

        // 滚轮缩放（在图片上）
        modalImg.addEventListener('wheel', onWheel, { passive: false });

        // 拖拽平移
        modalImg.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        // 触摸：滑动切换/拖动
        modalImg.addEventListener('touchstart', onTouchStart, { passive: true });
        modalImg.addEventListener('touchend', onTouchEnd);
        modalImg.addEventListener('touchmove', onTouchMove, { passive: false });

        // 双击切换缩放
        modalImg.addEventListener('dblclick', (e) => { e.preventDefault(); e.stopPropagation(); lastDbl = Date.now(); toggleZoom(e); });

        // 图片区域单击处理
        modalImg.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (Date.now() - lastDbl < 300) return; // 刚双击过
          if (scale > 1) return; // 放大时不切换
          
          const rect = modalImg.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // 点击图片下方空白区域关闭预览
          if (y > rect.height * 0.8) {
            close();
            return;
          }
          
          // 点击图片左右半屏切换（仅在图片上半部分）
          if (imgs.length > 1) {
            if (x < rect.width / 2) prev(); else next();
          }
        });

        // 阻止页面滚动
        overlay.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
      }

      function openModal(index) {
        currentIndex = index;
        if (!overlay) buildOverlay();
        updateImage();
        resetTransform();
        overlay.style.display = 'flex';
        bodyOverflowPrev = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        overlay.focus();
      }

      function close() {
        if (!overlay) return;
        overlay.style.display = 'none';
        document.body.style.overflow = bodyOverflowPrev || '';
      }

      function updateImage() {
        if (!modalImg) return;
        const src = imgs[currentIndex]?.getAttribute('src') || imgs[currentIndex]?.getAttribute('data-src');
        if (src) modalImg.src = src;
        modalImg.style.transform = '';
      }

      function prev() {
        currentIndex = (currentIndex - 1 + imgs.length) % imgs.length;
        updateImage();
        resetTransform();
      }

      function next() {
        currentIndex = (currentIndex + 1) % imgs.length;
        updateImage();
        resetTransform();
      }

      function resetTransform() {
        scale = 1; translateX = 0; translateY = 0;
        applyTransform();
      }

      function applyTransform() {
        if (!modalImg) return;
        modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        modalImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
      }

      function onKey(e) {
        if (!overlay || overlay.style.display === 'none') return;
        if (e.key === 'Escape') close();
        else if (e.key === 'ArrowLeft' && imgs.length > 1) prev();
        else if (e.key === 'ArrowRight' && imgs.length > 1) next();
      }

      function onWheel(e) {
        e.preventDefault();
        const delta = -e.deltaY;
        const zoomIntensity = 0.0015;
        const newScale = clamp(scale * (1 + delta * zoomIntensity), 1, 5);
        const rect = modalImg.getBoundingClientRect();
        const cx = e.clientX - rect.left - rect.width / 2;
        const cy = e.clientY - rect.top - rect.height / 2;
        translateX += cx * (1 - newScale / scale);
        translateY += cy * (1 - newScale / scale);
        scale = newScale;
        applyTransform();
      }

      function onMouseDown(e) {
        if (scale <= 1) return;
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        originX = translateX;
        originY = translateY;
        modalImg.style.cursor = 'grabbing';
      }

      function onMouseMove(e) {
        if (!isDragging) return;
        translateX = originX + (e.clientX - dragStartX);
        translateY = originY + (e.clientY - dragStartY);
        applyTransform();
      }

      function onMouseUp() {
        if (!isDragging) return;
        isDragging = false;
        modalImg.style.cursor = 'grab';
      }

      function toggleZoom(e) {
        if (!modalImg) return;
        if (scale === 1) {
          const rect = modalImg.getBoundingClientRect();
          const cx = e.clientX - rect.left - rect.width / 2;
          const cy = e.clientY - rect.top - rect.height / 2;
          scale = 2;
          translateX -= cx;
          translateY -= cy;
        } else {
          scale = 1; translateX = 0; translateY = 0;
        }
        applyTransform();
      }

      function onTouchStart(e) {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchMoved = false;
        } else if (e.touches.length === 2) {
          const t1 = e.touches[0], t2 = e.touches[1];
          pinchLastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY) || 0;
        }
      }

      function onTouchMove(e) {
        if (e.touches.length === 1) {
          const dx = e.touches[0].clientX - touchStartX;
          const dy = e.touches[0].clientY - touchStartY;
          if (scale > 1) {
            e.preventDefault();
            translateX += dx * 0.5;
            translateY += dy * 0.5;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            applyTransform();
          } else {
            // 检测水平或垂直滑动
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) touchMoved = true;
          }
        } else if (e.touches.length === 2) {
          e.preventDefault();
          const t1 = e.touches[0], t2 = e.touches[1];
          const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY) || 0;
          if (pinchLastDist === 0) { pinchLastDist = dist; return; }
          const ratio = dist / (pinchLastDist || dist);
          const newScale = clamp(scale * ratio, 1, 5);
          const rect = modalImg.getBoundingClientRect();
          const midX = (t1.clientX + t2.clientX) / 2;
          const midY = (t1.clientY + t2.clientY) / 2;
          const cx = midX - rect.left - rect.width / 2;
          const cy = midY - rect.top - rect.height / 2;
          translateX += cx * (1 - newScale / scale);
          translateY += cy * (1 - newScale / scale);
          scale = newScale;
          pinchLastDist = dist;
          touchMoved = true;
          applyTransform();
        }
      }

      function onTouchEnd(e) {
        const now = Date.now();
        const endX = (e.changedTouches && e.changedTouches[0].clientX) || touchStartX;
        const endY = (e.changedTouches && e.changedTouches[0].clientY) || touchStartY;
        pinchLastDist = 0;
        // 双击触摸缩放（移动端）
        if (Math.abs(endX - touchStartX) < 10 && Math.abs(endY - touchStartY) < 10) {
          if (now - lastTap < 300) {
            lastDbl = now; // 抑制 overlay 点击切换
            // 构造一个类似鼠标事件的对象传给 toggleZoom
            toggleZoom({ clientX: endX, clientY: endY });
            lastTap = 0;
            return;
          }
          lastTap = now;
          lastTapX = endX; lastTapY = endY;
        }

        // 单击（轻触）图片左右半屏切换（仅缩放为 1 且没有滑动时）
        if (scale === 1 && !touchMoved) {
          const rect = modalImg.getBoundingClientRect();
          const x = endX - rect.left;
          if (imgs.length > 1) {
            if (x < rect.width / 2) prev(); else next();
            return;
          }
        }

        // 滑动切换逻辑：支持水平和垂直滑动
        if (scale === 1 && touchMoved && imgs.length > 1) {
          const diffX = endX - touchStartX;
          const diffY = endY - touchStartY;
          
          // 判断是水平滑动还是垂直滑动
          if (Math.abs(diffX) > Math.abs(diffY)) {
            // 水平滑动：左右切换
            if (Math.abs(diffX) > 40) {
              if (diffX > 0) prev(); else next();
            }
          } else {
            // 垂直滑动：上下切换（类似抖音）
            if (Math.abs(diffY) > 40) {
              if (diffY > 0) prev(); else next();
            }
          }
        }
      }

      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    })();
  </script>
</div>
